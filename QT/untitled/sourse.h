#ifndef SOURSE_H
#define SOURSE_H

#endif // SOURSE_H
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

void fix_file_Data_Pre()
{
        FILE* f1 = fopen("script\\Data_Pre.py", "a+");
        fprintf(f1, "import torch\n");
        fprintf(f1, "import os,glob\n");
        fprintf(f1, "import random,csv\n");
        fprintf(f1, "from PIL import Image\n");
        fprintf(f1, "from torchvision import transforms\n");
        fprintf(f1, "from torch.utils.data import Dataset,DataLoader\n");
        fprintf(f1, "class Data(Dataset):\n");
        fprintf(f1, "\tdef __init__(self,root,resize,mode):\n");
        fprintf(f1, "\t\tsuper(Data,self).__init__()\n");
        fprintf(f1, "\t\tself.root=root\n");
        fprintf(f1, "\t\tself.resize=resize\n");
        fprintf(f1, "\t\tself.name2label={}\n");
        fprintf(f1, "\t\tfor name in sorted(os.listdir(os.path.join(root))):\n");
        fprintf(f1, "\t\t\tif not os.path.isdir(os.path.join(root,name)):\n");
        fprintf(f1, "\t\t\t\tcontinue\n");
        fprintf(f1, "\t\t\tself.name2label[name]=len(self.name2label.keys())\n");
        fprintf(f1, "\t\tself.images,self.labels=self.load_csv('images.csv')\n");
        fprintf(f1, "\t\tif mode=='train':\n");
        fprintf(f1, "\t\t\tself.images=self.images[:int(0.6*len(self.images))]\n");
        fprintf(f1, "\t\t\tself.labels=self.labels[:int(0.6*len(self.labels))]\n");
        fprintf(f1, "\t\telif mode=='val':\n");
        fprintf(f1, "\t\t\tself.images=self.images[int(0.6*len(self.images)):int(0.8*len(self.images))]\n");
        fprintf(f1, "\t\t\tself.labels=self.labels[int(0.6*len(self.labels)):int(0.8*len(self.labels))]\n");
        fprintf(f1, "\t\telse:\n");
        fprintf(f1, "\t\t\tself.images=self.images[int(0.8*len(self.images)):]\n");
        fprintf(f1, "\t\t\tself.labels=self.labels[int(0.8*len(self.images)):]\n");
        fprintf(f1, "\tdef load_csv(self,filename):\n");
        fprintf(f1, "\t\tif not os.path.exists(os.path.join(self.root,filename)):\n");
        fprintf(f1, "\t\t\timages=[]\n");
        fprintf(f1, "\t\t\tfor name in self.name2label.keys():\n");
        fprintf(f1, "\t\t\t\timages+=glob.glob(os.path.join(self.root,name,'*.png'))\n");
        fprintf(f1, "\t\t\t\timages+=glob.glob(os.path.join(self.root,name,'*.jpg'))\n");
        fprintf(f1, "\t\t\t\timages+=glob.glob(os.path.join(self.root,name,'*.jpeg'))\n");
        fprintf(f1, "\t\t\tprint(len(images))\n");
        fprintf(f1, "\t\t\trandom.shuffle(images)\n");
        fprintf(f1, "\t\t\twith open(os.path.join(self.root,filename),mode='w',nemline='') as f:\n");
        fprintf(f1, "\t\t\t\twriter=csv.writer(f)\n");
        fprintf(f1, "\t\t\t\tfor img in images:\n");
        fprintf(f1, "\t\t\t\t\tname=img.split(os.sep)[-2]\n");
        fprintf(f1, "\t\t\t\t\tlabel=self.name2label[name]\n");
        fprintf(f1, "\t\t\t\t\twriter.writerow([img,label])\n");
        fprintf(f1, "\t\t\t\tprint('write into csv into :',filename)\n");
        fprintf(f1, "\t\timages,labels=[],[]\n");
        fprintf(f1, "\t\twith open(os.path.join(self.root,filename)) as f:\n");
        fprintf(f1, "\t\t\treader=csv.reader(f)\n");
        fprintf(f1, "\t\t\tfor row in reader:\n");
        fprintf(f1, "\t\t\t\timg,label=row\n");
        fprintf(f1, "\t\t\t\tlabel=int(label)\n");
        fprintf(f1, "\t\t\t\timages.append(img)\n");
        fprintf(f1, "\t\t\t\tlabels.append(label)\n");
        fprintf(f1, "\t\tassert len(images)==len(labels)\n");
        fprintf(f1, "\t\treturn images,labels\n");
        fprintf(f1, "\tdef __len__(self):\n");
        fprintf(f1, "\t\treturn len(self.images)\n");
        fprintf(f1, "\tdef denormalize(self,x_hat):\n");
        fprintf(f1, "\t\tmean=[0.485,0.456,0.406]\n");
        fprintf(f1, "\t\tstd=[0.229,0.224,0.225]\n");
        fprintf(f1, "\t\tmean=torch.tensor(mean).unsqueeze(1).unsqueeze(1)\n");
        fprintf(f1, "\t\tstd=torch.tensor(std).unsqueeze(1).unsqueeze(1)\n");
        fprintf(f1, "\t\tx=x_hat*std+mean\n");
        fprintf(f1, "\t\treturn x\n");
        fprintf(f1, "\tdef __getitem__(self,idx):\n");
        fprintf(f1, "\t\timg,label=self.images[idx],self.labels[idx]\n");
        fprintf(f1, "\t\ttf=transforms.Compose([lambda x:Image.open(x).convert('RGB'),transforms.Resize((int(self.resize*1.25),int(self.resize*1.25))),transforms.RandomRotation(15),transforms.CenterCrop(self.resize),transforms.ToTensor(),transforms.Normalize(mean=[0.485,0.456,0.406],std=[0.229,0.224,0.225])])\n");
        fprintf(f1, "\t\timg=tf(img)\n");
        fprintf(f1, "\t\tlabel=torch.tensor(label)\n");
        fprintf(f1, "\t\treturn img,label\n");
        fprintf(f1, "def main():\n");
        fprintf(f1, "\tdb=Data('train_data',64,'train')\n");
        fprintf(f1, "\tDataLoader(db,batch_size=32,shuffle=True,num_workers=8)\n");
        fprintf(f1, "if __name__=='__main__':\n");
        fprintf(f1, "\tmain()\n");
        fclose(f1);
}

void fix_file_resnet()
{
    FILE* f1=fopen("script\\resnet.py","a+");
    fprintf(f1,"import torch\n");
    fprintf(f1,"from torch import nn\n");
    fprintf(f1,"from torch.nn import functional as F\n");
    fprintf(f1,"import codecs\n");
    fprintf(f1,"class ResBlk(nn.Module):\n");
    fprintf(f1,"\tdef __init__(self,ch_in,ch_out,stride=1):\n");
    fprintf(f1,"\t\tsuper(ResBlk,self).__init__()\n");
    fprintf(f1,"\t\tself.conv1=nn.Conv2d(ch_in,ch_out,kernel_size=3,stride=stride,padding=1)\n");
    fprintf(f1,"\t\tself.bn1=nn.BatchNorm2d(ch_out)\n");
    fprintf(f1,"\t\tself.conv2=nn.Conv2d(ch_out,ch_out,kernel_size=3,stride=1,padding=1)\n");
    fprintf(f1,"\t\tself.bn2=nn.BatchNorm2d(ch_out)\n");
    fprintf(f1,"\t\tself.extra=nn.Sequential()\n");
    fprintf(f1,"\t\tif ch_out != ch_in:\n");
    fprintf(f1,"\t\t\tself.extra=nn.Sequential(nn.Conv2d(ch_in,ch_out,kernel_size=1,stride=stride),nn.BatchNorm2d(ch_out))\n");
    fprintf(f1,"\tdef forward(self,x):\n");
    fprintf(f1,"\t\tout=F.relu(self.bn1(self.conv1(x)))\n");
    fprintf(f1,"\t\tout=self.bn2(self.conv2(out))\n");
    fprintf(f1,"\t\tout=self.extra(x)+out\n");
    fprintf(f1,"\t\tout=F.relu(out)\n");
    fprintf(f1,"\t\treturn out\n");
    fprintf(f1,"class ResNet18(nn.Module):\n");
    fprintf(f1,"\tdef __init__(self,num_class):\n");
    fprintf(f1,"\t\tsuper(ResNet18,self).__init__()\n");
    fprintf(f1,"\t\tself.conv1=nn.Sequential(nn.Conv2d(3,16,kernel_size=3,stride=3,padding=0),nn.BatchNorm2d(16))\n");
    fprintf(f1,"\t\tself.blk1=ResBlk(16,32,stride=3)\n");
    fprintf(f1,"\t\tself.blk2=ResBlk(32,64,stride=3)\n");
    fprintf(f1,"\t\tself.blk3=ResBlk(64,128,stride=2)\n");
    fprintf(f1,"\t\tself.blk4=ResBlk(128,256,stride=2)\n");
    fprintf(f1,"\t\tself.outlayer=nn.Linear(256*3*3,num_class)\n");
    fprintf(f1,"\tdef forward(self,x):\n");
    fprintf(f1,"\t\tx=F.relu(self.conv1(x))\n");
    fprintf(f1,"\t\tx=self.blk1(x)\n");
    fprintf(f1,"\t\tx=self.blk2(x)\n");
    fprintf(f1,"\t\tx=self.blk3(x)\n");
    fprintf(f1,"\t\tx=self.blk4(x)\n");
    fprintf(f1,"\t\tx=x.view(x.size(0),-1)\n");
    fprintf(f1,"\t\tx=self.outlayer(x)\n");
    fprintf(f1,"\t\treturn x\n");
    fprintf(f1,"def main():\n");
    fprintf(f1,"\tblk=ResBlk(64,128)\n");
    fprintf(f1,"\ttmp=torch.randn(2,64,224,224)\n");
    fprintf(f1,"\tout=blk(tmp)\n");
    fprintf(f1,"\tprint('block:',out.shape)\n");
    fprintf(f1,"\tmodel=ResNet18(5)\n");
    fprintf(f1,"\ttmp=torch.randn(2,3,224,224)\n");
    fprintf(f1,"\tout=model(tmp)\n");
    fprintf(f1,"\tprint('resnet:',out.shape)\n");
    fprintf(f1,"\tp=sum(map(lambda p:p.numel(), model.parameters()))\n");
    fprintf(f1,"\tprint('parameters size:', p)\n");
    fprintf(f1,"if __name__=='__main__':\n");
    fprintf(f1,"\tmain()\n");
    fclose(f1);
}

void fix_file_Test_model()
{
    FILE* f1 = fopen("script\\Test_model.dll", "a+");
        fprintf(f1, "import sys\n");
        fprintf(f1, "import torch\n");
        fprintf(f1, "from PIL import Image\n");
        fprintf(f1, "from torchvision import transforms\n");
        fprintf(f1, "import visdom\n");
        fprintf(f1, "from torch import optim , nn\n");
        fprintf(f1, "import os\n");
        fprintf(f1, "classes=('harmful','kitch','others','recyc')\n");
        fprintf(f1, "if torch.cuda.is_available():\n");
        fprintf(f1, "\tdevice = torch.device('cuda')\n");
        fprintf(f1, "\ttransform = transforms.Compose([\n");
        fprintf(f1, "\t\ttransforms.Resize(256),\n");
        fprintf(f1, "\t\ttransforms.CenterCrops(224),\n");
        fprintf(f1, "\t\ttransforms.ToTensor(),\n");
        fprintf(f1, "\t\ttransforms.Normalize(mean=[0.485,0.456,0.406],\n");
        fprintf(f1, "\t\t\t\tstd=[0.229,0.224,0.225])\n");
        fprintf(f1, "\t\t\t])\n");
        fprintf(f1, "else:\n");
        fprintf(f1, "\tdevice = torch.device('cpu')\n");
        fprintf(f1, "\ttransform=transforms.Compose([\n");
        fprintf(f1, "\t\ttransforms.Resize(256),\n");
        fprintf(f1, "\t\ttransforms.CenterCrop(224),\n");
        fprintf(f1, "\t\ttransforms.ToTensor(),\n");
        fprintf(f1, "\t\ttransforms.Normalize(mean=[0.485,0.456,0.406],\n");
        fprintf(f1, "\t\t\t\tstd=[0.229,0.224,0.225])\n");
        fprintf(f1, "\t\t\t])\n");
        fprintf(f1, "def predict(img_path):\n");
        fprintf(f1, "\tif torch.cuda.is_available():\n");
        fprintf(f1, "\t\tnet=torch.load('model.dll',map_location='cuda')\n");
        fprintf(f1, "\t\tnet=net.to(device)\n");
        fprintf(f1, "\t\ttorch.no_grad()\n");
        fprintf(f1, "\t\timg=Image.open(img_path)\n");
        fprintf(f1, "\t\timg=transform(img).unsqueeze(0)\n");
        fprintf(f1, "\t\timg_=img.to(device)\n");
        fprintf(f1, "\t\toutputs=net(img_)\n");
        fprintf(f1, "\t\t_,predicted=torch.max(outputs,1)\n");
        fprintf(f1, "\telse:\n");
        fprintf(f1, "\t\tnet=torch.load('model.dll',map_location='cpu')\n");
        fprintf(f1, "\t\tnet=net.to(device)\n");
        fprintf(f1, "\t\ttorch.no_grad()\n");
        fprintf(f1, "\t\timg=Image.open(img_path)\n");
        fprintf(f1, "\t\timg=transform(img).unsqueeze(0)\n");
        fprintf(f1, "\t\timg_=img.to(device)\n");
        fprintf(f1, "\t\toutputs=net(img_)\n");
        fprintf(f1, "\t\t_,predicted=torch.max(outputs,1)\n");
        fprintf(f1, "\tprint(classes[predicted[0]])\n");
        fprintf(f1, "\tpath='connect.dll'\n");
        fprintf(f1, "\tif os.path.exists(path):\n");
        fprintf(f1, "\t\tos.remove(path)\n");
        fprintf(f1, "\telse:\n");
        fprintf(f1, "\t\tprint('successfully create the file:connect.dll')\n");
        fprintf(f1, "\tif classes[predicted[0]]=='harmful':\n");
        fprintf(f1, "\t\t#print('1')\n");
        fprintf(f1, "\t\tcreate_file(1)\n");
        fprintf(f1, "\tif classes[predicted[0]]=='kitch':\n");
        fprintf(f1, "\t\t#print('2')\n");
        fprintf(f1, "\t\tcreate_file(2)\n");
        fprintf(f1, "\tif classes[predicted[0]]=='others':\n");
        fprintf(f1, "\t\t#print('3')\n");
        fprintf(f1, "\t\tcreate_file(3)\n");
        fprintf(f1, "\tif classes[predicted[0]]=='recyc':\n");
        fprintf(f1, "\t\t#print('4')\n");
        fprintf(f1, "\t\tcreate_file(4)\n");
        fprintf(f1, "def create_file(a):\n");
        fprintf(f1, "\tif a==1:\n");
        fprintf(f1, "\t\ttry:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','r+')\n");
        fprintf(f1, "\t\texcept FileNotFoundError:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','a+')\n");
        fprintf(f1, "\tif a==2:\n");
        fprintf(f1, "\t\ttry:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','r+')\n");
        fprintf(f1, "\t\texcept FileNotFoundError:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','a+')\n");
        fprintf(f1, "\tif a==3:\n");
        fprintf(f1, "\t\ttry:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','r+')\n");
        fprintf(f1, "\t\texcept FileNotFoundError:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','a+')\n");
        fprintf(f1, "\tif a==4:\n");
        fprintf(f1, "\t\ttry:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','r+')\n");
        fprintf(f1, "\t\texcept FileNotFoundError:\n");
        fprintf(f1, "\t\t\tfile=open('connect.dll','a+')\n");
        fprintf(f1, "\twrite_file(a)\n");
        fprintf(f1, "def write_file(a):\n");
        fprintf(f1, "\tif a==1:\n");
        fprintf(f1, "\t\twith open('connect.dll','a+',encoding='utf-8') as f:\n");
        fprintf(f1, "\t\t\ttext='harmful'\n");
        fprintf(f1, "\t\t\tf.write(text)\n");
        fprintf(f1, "\tif a==2:\n");
        fprintf(f1, "\t\twith open('connect.dll','a+',encoding='utf-8') as f:\n");
        fprintf(f1, "\t\t\ttext='kitch'\n");
        fprintf(f1, "\t\t\tf.write(text)\n");
        fprintf(f1, "\tif a==3:\n");
        fprintf(f1, "\t\twith open('connect.dll','a+',encoding='utf-8') as f:\n");
        fprintf(f1, "\t\t\ttext='others'\n");
        fprintf(f1, "\t\t\tf.write(text)\n");
        fprintf(f1, "\tif a==4:\n");
        fprintf(f1, "\t\twith open('connect.dll','a+',encoding='utf-8') as f:\n");
        fprintf(f1, "\t\t\ttext='recyc'\n");
        fprintf(f1, "\t\t\tf.write(text)\n");
        fprintf(f1, "\nif __name__=='__main__':\n");
        fprintf(f1, "\tpredict('./test/1.jpg')\n");
        fclose(f1);
}

void fix_file_train()
{
    FILE* f1 = fopen("train.dll", "a+");
        fprintf(f1, "import torch\n");
        fprintf(f1, "import visdom\n");
        fprintf(f1, "from torch import optim, nn\n");
        fprintf(f1, "from utils import Flatten\n");
        fprintf(f1, "from Data_Pre import Data\n");
        fprintf(f1, "from torch.utils.data import DataLoader\n");
        fprintf(f1, "from torchvision.models import resnet18\n");
        fprintf(f1, "batchsz=32\n");
        fprintf(f1, "lr = 1e-4\n");
        fprintf(f1, "epochs =20\n");
        fprintf(f1, "device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n");
        fprintf(f1, "torch.manual_seed(1234)\n");
        fprintf(f1, "train_db=Data('train_data',224,mode='train')\n");
        fprintf(f1, "val_db=Data('train_data',224,mode='val')\n");
        fprintf(f1, "test_db=Data('train_data',224,mode='test')\n");
        fprintf(f1, "train_loader=DataLoader(train_db,batch_size=batchsz,shuffle=True,num_workers=4)\n");
        fprintf(f1, "val_loader=DataLoader(val_db,batch_size=batchsz,num_workers=4)\n");
        fprintf(f1, "test_loader=DataLoader(test_db,batch_size=batchsz,num_workers=4)\n");
        fprintf(f1, "viz=visdom.Visdom()\n");
        fprintf(f1, "def evalute(model,loader):\n");
        fprintf(f1, "\tmodel.eval()\n");
        fprintf(f1, "\tcorrect=0\n");
        fprintf(f1, "\ttotal=len(loader.dataset)\n");
        fprintf(f1, "\tfor x,y in loader:\n");
        fprintf(f1, "\t\tx,y =x.to(device),y.to(device)\n");
        fprintf(f1, "\t\twith torch.no_grad():\n");
        fprintf(f1, "\t\t\tlogits=model(x)\n");
        fprintf(f1, "\t\t\tpred=logits.argmax(dim=1)\n");
        fprintf(f1, "\t\tcorrect+=torch.eq(pred,y).sum().float().item()\n");
        fprintf(f1, "\treturn correct / total\n");
        fprintf(f1, "def main():\n");
        fprintf(f1, "\ttrained_model=resnet18(pretrained=True)\n");
        fprintf(f1, "\tmodel = nn.Sequential(*list(trained_model.children())[:-1],Flatten(),nn.Linear(512,6)).to(device)\n");
        fprintf(f1, "\toptimizer=optim.Adam(model.parameters(),lr=lr)\n");
        fprintf(f1, "\tcriteon=nn.CrossEntropyLoss()\n");
        fprintf(f1, "\tbest_acc,best_epoch=0,0\n");
        fprintf(f1, "\tglobal_step=0\n");
        fprintf(f1, "\tviz.line([[0.0,0.0]],[0.],win='test',opts=dict(title='Loss on Training Data and Accuracy on Training Data',xlabel='Epochs',ylabel='Loss and Accuracy',legend=['loss','val_acc']))\n");
        fprintf(f1, "\tfor epoch in range(epochs):\n");
        fprintf(f1, "\t\tfor step,(x,y) in enumerate(train_loader):\n");
        fprintf(f1, "\t\t\tx,y = x.to(device),y.to(device)\n");
        fprintf(f1, "\t\t\tmodel.train()\n");
        fprintf(f1, "\t\t\tlogits=model(x)\n");
        fprintf(f1, "\t\t\tloss=criteon(logits,y)\n");
        fprintf(f1, "\t\t\toptimizer.zero_grad()\n");
        fprintf(f1, "\t\t\tloss.backward()\n");
        fprintf(f1, "\t\t\toptimizer.step()\n");
        fprintf(f1, "\t\t\tviz.line([[loss.item(),evalute(model,val_loader)]],[global_step],win='test',update='append')\n");
        fprintf(f1, "\t\t\tglobal_step+=1\n");
        fprintf(f1, "\t\tif epoch%1==0:\n");
        fprintf(f1, "\t\t\tprint('the '+str(epoch+1)+' epoch'+' training......')\n");						//fprintf(f1, "\t\t\tprint('第 '+str(epoch+1)+' 批'+' training……')\n");
        fprintf(f1, "\t\t\tval_acc=evalute(model,val_loader)\n");
        //fixed bug that cause python script stop running
        fprintf(f1, "\t\t\tif val_acc>best_acc:\n");
        fprintf(f1, "\t\t\t\tbest_epoch=epoch\n");
        fprintf(f1, "\t\t\t\tbest_acc=val_acc\n");
        fprintf(f1, "\t\t\t\ttorch.save(model.state_dict(),'best_trans.mdl')\n");
        fprintf(f1, "\tprint('best accuracy:',best_acc,'best epoch:',(best_epoch+1))\n");									//fprintf(f1, "\tprint('最好的准确率：',best_acc,'最好的批次：',(best_epoch+1))\n");
        fprintf(f1, "\ttorch.save(model,'model.dll')\n");
        fprintf(f1, "\tprint('loading model......')\n");													//fprintf(f1, "\tprint('正在加载模型......')\n");
        fprintf(f1, "\ttest_acc=evalute(model,test_loader)\n");
        fprintf(f1, "\tprint('test accuracy:',test_acc)\n");													//fprintf(f1, "\tprint('测试准确率:',test_acc)\n");
        fprintf(f1, "\tprint('successfully save the best model ')\n");												//fprintf(f1, "\tprint('保存最好效果模型成功！')\n");
        fprintf(f1, "if __name__=='__main__':\n");
        fprintf(f1, "\tmain()\n");
        fclose(f1);
}

void fix_file_utils()
{
    FILE* f1 = fopen("utils.py", "a+");
        fprintf(f1, "import torch\n");
        fprintf(f1, "from torch import nn\n");
        fprintf(f1, "from matplotlib import pyplot as plt\n");
        fprintf(f1, "class Flatten(nn.Module):\n");
        fprintf(f1, "\tdef __init__(self):\n");
        fprintf(f1, "\t\tsuper(Flatten,self).__init__()\n");
        fprintf(f1, "\tdef forward(self,x):\n");
        fprintf(f1, "\t\tshape=torch.prod(torch.tensor(x.shape[1:])).item()\n");
        fprintf(f1, "\t\treturn x.view(-1,shape)\n");
        fprintf(f1, "def plot_image(img,label,name):\n");
        fprintf(f1, "\tfig=plt.figure()\n");
        fprintf(f1, "\tfor i in range(6):\n");
        fprintf(f1, "\t\tplt.subplot(2,3,i+1)\n");
        fprintf(f1, "\t\tplt.tight_layout()\n");
        fprintf(f1, "\t\tplt.imshow(img[i][0]*0.3081+0.1307,cmap='gray',interpolation='none')\n");
        fprintf(f1, "\t\tplt.title('{}:{}'.format(name,label[i].item()))\n");
        fprintf(f1, "\t\tplt.xticks([])\n");
        fprintf(f1, "\t\tplt.yticks([])\n");
        fprintf(f1, "\tplt.show()\n");
        fclose(f1);
}


void fix_file_readme()
{
        FILE* fp = fopen("readme.txt", "a+");
        fprintf(fp, "=================================================\n");
        fprintf(fp, "this program is powered by lry\n");
        fprintf(fp, "all rights reserved 2020~2021\n");
        fprintf(fp, "this file is released by the program garbage_classifation_main_progress.exe\n");
        fprintf(fp, "=================================================\n");
        fprintf(fp, "this program should have these files below:\n");
        fprintf(fp, "1	:grabage_classifation_main_progress.exe\n");
        fprintf(fp, "2	:model.dll\n");
        fprintf(fp, "3	:Test_model.dll\n");
        fprintf(fp, "4	:train.dll\n");
        fprintf(fp, "5	:utils.py\n");
        fprintf(fp, "6	:Data_Pre.py\n");
        fprintf(fp, "7	:readme.txt\n");
        fprintf(fp, "=================================================================\n");
        fprintf(fp, "if you find out the information are not match with this file,please connect with the program builder lry\n");
        fprintf(fp, "author			:lry\n");
        fprintf(fp, "email address	:1224137702@qq.com\n");
        fprintf(fp, "=================================================================\n");
        fprintf(fp, "if you want to use this program , please install python(>=3.8.5)\n");
        fprintf(fp, "=================================================================\n");
        fprintf(fp, "now ,the information below is very important.\n");
        fprintf(fp, "this program can have the accuracy 98.2%c\n", '%');
        fprintf(fp, "val_acc 96.4%c\n", '%');
        fprintf(fp, "=================================================================\n");
        fprintf(fp, "the way you use this program is that put the image(1.jpg)to test.model\n");
        fprintf(fp, "you can get the result in three seconds.\n");
        fprintf(fp, "and all the files have a signcode\n");
        fprintf(fp, "this versioon is better than the version before this program\n");
        fprintf(fp, "thank you for your usage\n");
        fclose(fp);
}

void fix_file_update_data()
{
    FILE* f1 = fopen("updatedata.txt", "rb");
        if (f1 != NULL)
        {
            fclose(f1);
            FILE* f2 = fopen("updatedata.txt", "w+");
            fprintf(f2, "version 1.0.1\n");
            fprintf(f2, "this verson can make simple classify\n");
            fprintf(f2, "version 2.0.1\n");
            fprintf(f2, "this version can run in a mode(lost something it have,still can run)\n");
            fprintf(f2, "add a signcode to this program\n");
            fprintf(f2, "version 3.0.1\n");
            fprintf(f2, "this program add some gui interface,easier for you to use\n");
            fprintf(f2, "version 3.1.1\n");
            fprintf(f2, "this version has fixed mouse problem\n");
            fprintf(f2, "version 3.1.2\n");
            fprintf(f2, "this version has fixed some problems\n");
            fprintf(f2, "version 4.0.0 BETA\n");
            fprintf(f2, "this version has two threads to monitor mouse messages.\n");
            fprintf(f2, "version 4.0.0\n");
            fprintf(f2, "this version has git to github\n");
            fprintf(f2, "version 4.0.1\n");
            fprintf(f2, "this version has makes a open sourse license.\n");
            fprintf(f2, "version 4.1.1\n");
            fprintf(f2, "this version has added a license for guests to use\n");
            fprintf(f2, "version 4.1.2\n");
            fprintf(f2, "this version has added a file that can uninstall this program\n");
            fprintf(f2, "version 4.1.3\n");
            fprintf(f2, "this version has fix the problem of uninstall.exe\n");
            fprintf(f2, "version 4.2.0\n");
            fprintf(f2, "this version has made a GUI_interface for guests\n");
            fprintf(f2, "version 5.0.0\n");
            fprintf(f2, "this version has transform the python script to execlute files\n");
            fprintf(f2, "version 5.0.1\n");
            fprintf(f2, "this version has fixed some problems\n");
            fprintf(f2, "version 6.0.0\n");
            fprintf(f2, "this version has fixed some known problems\n");
            fprintf(f2, "version 7.0.0\n");
            fprintf(f2, "this version has added a function : can read number from command,and fixed some problems\n");
            fprintf(f2, "version 7.0.1\n");
            fprintf(f2, "this version has added api to commandline.\n");
            fprintf(f2, "version 7.0.2\n");
            fprintf(f2, "this version has fixed some known problems.\n");
            fprintf(f2,"version7.0.3\n");
            fprintf(f2,"this version has fixed some known bugs.\n");
            fprintf(f2,"version 7.0.4\n");
            fprintf(f2,"this version has improved compute speed.\n");
            fprintf(f2,"version 7.0.5\n");
            fprintf(f2,"this version has fixed some bugs that can make this program stop running\n");
            fprintf(f2,"version 7.0.6\n");
            fprintf(f2,"this version has fixed a serious bug that cannot recognize recyclable garbage.\ni have changed python script\n");
            fprintf(f2, "version 7.1.0\n");
            fprintf(f2, "this version has fixed some known problems\nthis version has fixed some bugs \n security update\n");
            fprintf(f2,"version 8.0.1\n");
            fprintf(f2,"this version has fixed some problems\n this version has fixed mouse message and fixed some security problem\nsecurity update\n");
            fclose(f2);
        }
        if (f1 == NULL)
        {
            FILE* f2 = fopen("updatedata.txt", "a+");
            fprintf(f2, "version 1.0.1\n");
            fprintf(f2, "this verson can make simple classify\n");
            fprintf(f2, "version 2.0.1\n");
            fprintf(f2, "this version can run in a mode(lost something it have,still can run)\n");
            fprintf(f2, "add a signcode to this program\n");
            fprintf(f2, "version 3.0.1\n");
            fprintf(f2, "this program add some gui interface,easier for you to use\n");
            fprintf(f2, "version 3.1.1\n");
            fprintf(f2, "this version has fixed mouse problem\n");
            fprintf(f2, "version 3.1.2\n");
            fprintf(f2, "this version has fixed some problems\n");
            fprintf(f2, "version 4.0.0 BETA\n");
            fprintf(f2, "this version has two threads to monitor mouse messages.\n");
            fprintf(f2, "version 4.0.0\n");
            fprintf(f2, "this version has git to github\n");
            fprintf(f2, "version 4.0.1\n");
            fprintf(f2, "this version has makes a open sourse license.\n");
            fprintf(f2, "version 4.1.1\n");
            fprintf(f2, "this version has added a license for guests to use\n");
            fprintf(f2, "version 4.1.2\n");
            fprintf(f2, "this version has added a file that can uninstall this program\n");
            fprintf(f2, "version 4.1.3\n");
            fprintf(f2, "this version has fix the problem of uninstall.exe\n");
            fprintf(f2, "version 4.2.0\n");
            fprintf(f2, "this version has made a GUI_interface for guests\n");
            fprintf(f2, "version 5.0.0\n");
            fprintf(f2, "this version has transform the python script to execlute files\n");
            fprintf(f2, "version 5.0.1\n");
            fprintf(f2, "this version has fixed some problems\n");
            fprintf(f2, "version 6.0.0\n");
            fprintf(f2, "this version has fixed some known problems\n");
            fprintf(f2, "version 7.0.0\n");
            fprintf(f2, "this version has added a function : can read number from command,and fixed some problems\n");
            fprintf(f2, "version 7.0.1\n");
            fprintf(f2, "this version has added api to commandline.\n");
            fprintf(f2, "version 7.0.2\n");
            fprintf(f2, "this version has fixed some known problems.\n");
            fprintf(f2,"version7.0.3\n");
            fprintf(f2,"this version has fixed some known bugs.\n");
            fprintf(f2,"version 7.0.4\n");
            fprintf(f2,"this version has improved compute speed.\n");
            fprintf(f2,"version 7.0.5\n");
            fprintf(f2,"this version has fixed some bugs that can make this program stop running\n");
            fprintf(f2,"version 7.0.6\n");
            fprintf(f2,"this version has fixed a serious bug that cannot recognize recyclable garbage.\ni have changed python script\n");
            fprintf(f2, "version 7.1.0\n");
            fprintf(f2, "this version has fixed some known problems\nthis version has fixed some bugs \n security update\n");
            fprintf(f2,"version 8.0.1\n");
            fprintf(f2,"this version has fixed some problems\n this version has fixed mouse message and fixed some security problem\nsecurity update\n");
            fclose(f2);
        }
}
